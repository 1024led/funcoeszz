# ----------------------------------------------------------------------------
# Faz cálculos com datas e/ou converte data->num e num->data.
# Que dia vai ser daqui 45 dias? Quantos dias há entre duas datas? zzdata!
# Quando chamada com apenas um parâmetro funciona como conversor de data
# para número inteiro (N dias passados desde Epoch) e vice-versa.
# Obs.: Leva em conta os anos bissextos     (Epoch = 01/01/1970, editável)
# Uso: zzdata data|num [+|- data|num]
# Ex.: zzdata 22/12/1999 + 69
#      zzdata hoje - 5
#      zzdata 01/03/2000 - 11/11/1999
#      zzdata hoje - dd/mm/aaaa         <---- use sua data de nascimento
#
# Autor: Aurélio Marinho Jargas, www.aurelio.net
# Desde: 2003-02-07
# Versão: 2
# Licença: GPL
# ----------------------------------------------------------------------------
zzdata ()
{
	zzzz -h data $1 && return

	local yyyy mm dd dias_ano data dias i n y op dias_neste_mes
	local epoch=1970
	local primeira_data=1
	local dias_mes='31 28 31 30 31 30 31 31 30 31 30 31'     # jan-dez
	local dias_mes_rev='31 30 31 30 31 31 30 31 30 31 28 31' # dez-jan
	local data1=$1
	local operacao=$2
	local data2=$3
	local n1=$data1
	local n2=$data2

	# Referências para ano bissexto:
	#
	# A year is a leap year if it is evenly divisible by 4
	# ...but not if it's evenly divisible by 100
	# ...unless it's also evenly divisible by 400
	# http://timeanddate.com
	# http://www.delorie.com/gnu/docs/gcal/gcal_34.html
	
	# Verificação dos parâmetros
	[ $# -eq 3 -o $# -eq 1 ] || { zztool uso data; return; }

	# Esse bloco gigante define $n1 e $n2 baseado nas datas $data1 e $data2.
	# A data é transformada em um número inteiro (dias desde $epoch).
	# Exemplo: 27/07/2007 -> 13721
	# Este é numero usado para fazer os cálculos.
	for data in $data1 $data2
	do
		dias=0 # Guarda o total que irá para $n1 e $n2
		
		# Atalhos úteis para o dia atual
		if [ "$data" = 'hoje' -o "$data" = 'today' ]
		then
			# Qual a data de hoje?
			data=$(date +%d/%m/%Y)
			[ "$primeira_data" ] && data1=$data || data2=$data
		else
			# Valida o formato da data
			if ! ( zztool testa_data "$data" || zztool testa_numero_sinal "$data" )
			then
				echo "Data inválida '$data', deve ser dd/mm/aaaa"
				return
			fi
		fi
		
		# Se tem /, então é uma data e deve ser transformado em número
		if zztool grep_var / "$data"
		then
			n=1
			y=$epoch
			yyyy=${data##*/}
			mm=${data#*/}
			mm=${mm%/*}
			dd=${data%%/*}

			# Retira o zero dos dias e meses menores que 10
			mm=${mm#0}
			dd=${dd#0}

			# Define qual será a operação: adição ou subtração
			op=+
			[ $yyyy -lt $epoch ] && op=-
			
			# Ano -> dias
			while :
			do
				# Sim, os anos bissextos são levados em conta!
				dias_ano=365
				zztool testa_ano_bissexto $y && dias_ano=366
				
				# Vai somando (ou subtraindo) até chegar no ano corrente
				[ $y -eq $yyyy ] && break
				dias=$((dias $op dias_ano))
				y=$((y $op 1))
			done
			
			# Meses -> dias
			for i in $dias_mes
			do
				[ $n -eq $mm ] && break
				n=$((n+1))
				
				# Fevereiro de ano bissexto tem 29 dias
				[ $dias_ano -eq 366 -a $i -eq 28 ] && i=29
				
				dias=$((dias+$i))
			done
			
			# Somando os dias da data aos anos+meses já contados (-1)
			dias=$((dias+dd-1))
			
			[ "$primeira_data" ] && n1=$dias || n2=$dias
		fi
		primeira_data=
	done
	
	# Agora que ambas as datas são números inteiros, a conta é feita
	dias=$(($n1 $operacao $n2))
	
	# Se as duas datas foram informadas como dd/mm/aaaa,
	# o resultado é o próprio número de dias, então terminamos.
	if [ "${data1##??/*}" = "${data2##??/*}" ]
	then
		echo $dias
		return
	fi
	
	# Como não caímos no IF anterior, então o resultado será uma data.
	# É preciso converter o número inteiro para dd/mm/aaaa.
	#
	# Se o número inteiro for positivo, temos uma data DEPOIS de Epoch
	# Se o número inteiro for negativo, temos uma data ANTES de Epoch
	#      03/01/1970 = 2
	#      02/01/1970 = 1
	#      01/01/1970 = 0
	#      31/12/1969 = -1
	#      30/12/1969 = -2

	if [ $dias -ge 0 ]
	then
		# POSITIVO
		# Inicia em 01/01/1970 e avança no tempo
		y=$epoch          # ano
		mm=1              # mês
		operacao='+'      # direção
	else
		# NEGATIVO
		# Inicia em 31/12/1969 e retrocede no tempo
		y=$((epoch - 1))  # ano
		mm=12             # mês
		operacao='-'      # direção
		
		# Valor negativo complica, vamos positivar (abs)
		dias=$((0 - dias))
		
		# Os meses vão andar de trás pra frente
		dias_mes="$dias_mes_rev"
	fi

	# O número da Epoch é zero-based, agora vai virar one-based
	dd=$(($dias $operacao 1))
	
	# Dias -> Ano
	while :
	do
		# Novamente, o ano bissexto é levado em conta
		dias_ano=365
		zztool testa_ano_bissexto $y && dias_ano=366
		
		# Vai descontando os dias de cada ano para saber quantos anos cabem

		# Não muda o ano se o número de dias for insuficiente
		[ $dd -lt $dias_ano ] && break

		# Se for exatamente igual ao total de dias, não muda o
		# ano se estivermos indo adiante no tempo (> Epoch).
		# Caso contrário vai mudar pois cairemos no último dia
		# do ano anterior.
		[ $dd -eq $dias_ano -a $operacao = '+' ] && break

		dd=$((dd-dias_ano))
		y=$(($y $operacao 1))
	done
	yyyy=$y
	
	# Dias -> mês
	for i in $dias_mes
	do
		# Fevereiro de ano bissexto tem 29 dias
		[ $dias_ano -eq 366 -a $i -eq 28 ] && i=29
	
		# Calcula quantos meses cabem nos dias que sobraram
		
		# Não muda o mês se o número de dias for insuficiente
		[ $dd -lt $i ] && break
		
		# Se for exatamente igual ao total de dias, não muda o
		# mês se estivermos indo adiante no tempo (> Epoch).
		# Caso contrário vai mudar pois cairemos no último dia
		# do mês anterior.
		[ $dd -eq $i -a $operacao = '+' ] && break
		
		dd=$((dd-i))
		mm=$(($mm $operacao 1))
	done
	dias_neste_mes=$i
	
	# Ano e mês estão OK, agora sobraram apenas os dias
	
	# Se estivermos antes de Epoch, os número de dias indica quanto
	# devemos caminhar do último dia do mês até o primeiro
	[ $operacao = '-' ] && dd=$(($dias_neste_mes - $dd))
	
	# Restaura o zero dos meses e dias menores que 10
	[ $dd -le 9 ] && dd=0$dd
	[ $mm -le 9 ] && mm=0$mm
	
	# E finalmente mostra o resultado em formato de data
	echo $dd/$mm/$yyyy
}
