# ----------------------------------------------------------------------------
# Faz cálculos com datas e/ou converte data->num e num->data.
# Que dia vai ser daqui 45 dias? Quantos dias há entre duas datas? zzdata!
# Quando chamada com apenas um parâmetro funciona como conversor de data
# para número inteiro (N dias passados desde Epoch) e vice-versa.
# Obs.: Leva em conta os anos bissextos     (Epoch = 01/01/1970, editável)
# Uso: zzdata data [+|- data|número<d|m|a>]
# Ex.: zzdata 22/12/1999 + 69d
#      zzdata hoje + 5d
#      zzdata hoje + 5m
#      zzdata hoje + 5a
#      zzdata 01/03/2000 - 11/11/1999
#      zzdata hoje - dd/mm/aaaa         <---- use sua data de nascimento
#
# Autor: Aurélio Marinho Jargas, www.aurelio.net
# Desde: 2003-02-07
# Versão: 3
# Licença: GPL
# ----------------------------------------------------------------------------
zzdata ()
{
	zzzz -h data $1 && return

	local yyyy mm dd dias_ano data dias i m y op dias_mes dias_neste_mes
	local quantidade
	local grandeza='d'
	local epoch=1970
	local primeira_data=1
	local dias_mes_ok='31 28 31 30 31 30 31 31 30 31 30 31'  # jan-dez
	local dias_mes_rev='31 30 31 30 31 31 30 31 30 31 28 31' # dez-jan
	local data1=$1
	local operacao=$2
	local data2=$3
	local n1=$data1
	local n2=$data2

	# Verificação dos parâmetros
	[ $# -eq 3 -o $# -eq 1 ] || { zztool uso data; return; }

	# Esse bloco gigante define $n1 e $n2 baseado nas datas $data1 e $data2.
	# A data é transformada em um número inteiro (dias desde $epoch).
	# Este é numero usado para fazer os cálculos.
	# Exemplos:
	#      03/01/1970 = 2
	#      02/01/1970 = 1
	#      01/01/1970 = 0
	#      31/12/1969 = -1
	#      30/12/1969 = -2
	
	for data in $data1 $data2
	do
		# Atalhos úteis para o dia atual
		if [ "$data" = 'hoje' -o "$data" = 'today' ]
		then
			# Qual a data de hoje?
			data=$(date +%d/%m/%Y)
			[ "$primeira_data" ] && data1=$data || data2=$data
		else
			# Valida o formato da data
			if ! (
				zztool testa_data "$data" ||
				zztool testa_numero_sinal "$data" ||
				echo "$data" | grep '^[0-9][0-9]*[dma]$' >/dev/null
				)
			then
				echo "Data inválida '$data', deve ser dd/mm/aaaa"
				return
			fi
		fi
		
		# Se tem /, então é uma data e deve ser transformado em número
		if zztool grep_var / "$data"
		then
			# Extrai os componentes da data: ano, mês, dia
			yyyy=${data##*/}
			mm=${data#*/}
			mm=${mm%/*}
			dd=${data%%/*}

			# Retira o zero dos dias e meses menores que 10
			mm=${mm#0}
			dd=${dd#0}

			# 29/02 em um ano não-bissexto?
			if test $dd -eq 29 -a $mm -eq 2 && ! zztool testa_ano_bissexto $yyyy
			then
				echo "Data inválida '$data', pois $yyyy não é um ano bissexto"
				return
			fi
			
			# Define o marco inicial e a direção dos cálculos
			if [ $yyyy -ge $epoch ]
			then
				# +Epoch: Inicia em 01/01/1970 e avança no tempo
				y=$epoch          # ano
				m=1               # mês
				op='+'            # direção
				dias=0            # 01/01/1970 == 0
				dias_mes="$dias_mes_ok"
			else
				# -Epoch: Inicia em 31/12/1969 e retrocede no tempo
				y=$((epoch - 1))  # ano
				m=12              # mês
				op='-'            # direção
				dias=-1           # 31/12/1969 == -1
				dias_mes="$dias_mes_rev"
			fi

			# Ano -> dias
			while :
			do
				# Sim, os anos bissextos são levados em conta!
				dias_ano=365
				zztool testa_ano_bissexto $y && dias_ano=366
				
				# Vai somando (ou subtraindo) até chegar no ano corrente
				[ $y -eq $yyyy ] && break
				dias=$(($dias $op $dias_ano))
				y=$(($y $op 1))
			done
			
			# Meses -> dias
			for i in $dias_mes
			do
				# Fevereiro de ano bissexto tem 29 dias
				[ $dias_ano -eq 366 -a $i -eq 28 ] && i=29

				# Vai somando (ou subtraindo) até chegar no mês corrente
				[ $m -eq $mm ] && break
				m=$(($m $op 1))
				dias=$(($dias $op $i))
			done
			dias_neste_mes=$i

			# -Epoch: o número de dias indica o quanto deve-se
			# retroceder à partir do último dia do mês
			[ $op = '-' ] && dd=$(($dias_neste_mes - $dd))

			# Somando os dias da data aos anos+meses já contados.
			dias=$(($dias $op $dd))
			
			# +Epoch: É substraído um do resultado pois 01/01/1970 == 0
			[ $op = '+' ] && dias=$((dias - 1))
			
			# O número inteiro que representa a data é salvo em n1 ou n2
			[ "$primeira_data" ] && n1=$dias || n2=$dias

		# Delta de dias, meses ou anos
		# Exemplos: 1a, 15d, 4m
		elif zztool grep_var '[dma]' "$data"
		then
			quantidade=$(echo $data | sed 's/[^0-9]//g')
			grandeza=$(  echo $data | sed 's/[^dma]//g')

			# A grandeza também é guardada em n1 ou n2 para facilitar adiante
			[ "$primeira_data" -a "$grandeza" = 'd' ] && n1=$quantidade || n2=$quantidade
		fi
		primeira_data=
	done
	
	# Se há um delta, *deve* haver uma data
	if (zztool grep_var '[dma]' "$data1" && ! zztool grep_var / "$data2") ||
	   (zztool grep_var '[dma]' "$data2" && ! zztool grep_var / "$data1")
	then
		zztool uso data
		return
	fi
	
	### OK, neste ponto os dados do usuário já foram coletados e analisados
	### Agora só falta fazer os cálculos
	
	# Somar/substrair dias de uma data, ou calcular a diferença entre duas datas
	if test "$grandeza" = 'd'
	then
		# Note que as datas do usuário foram convertidas para números inteiros
		# No caso de delta, n1/n2 já guarda a quantidade numérica
		dias=$(($n1 $operacao $n2))
		
		# Lá na frente, fora desse IF, será decidido o que fazer com $dias

	# Se a grandeza não é em dias, pode ser meses ou anos
	else
		# Descobre qual dos dois argumentos é a data
		zztool grep_var / "$data1" && data_=$data1 || data_=$data2
		
		# Extrai os componentes da data: ano, mês, dia
		yyyy=${data_##*/}
		mm=${data_#*/}
		mm=${mm%/*}
		dd=${data_%%/*}
		# Retira o zero dos dias e meses menores que 10
		mm=${mm#0}
		dd=${dd#0}

		case "$grandeza" in
			# Meses
			m)
				mm=$(($mm $operacao $quantidade))

				# Se houver excedente no mês (>12), recalcula mês e ano
				yyyy=$(($yyyy + $mm / 12))
				mm=$(($mm % 12))
			
				# Se negativou, ajusta os cálculos (voltou um ano)
				if test $mm -le 0
				then
					yyyy=$(($yyyy - 1))
					mm=$((12 + $mm))
				fi
			;;
			# Anos
			a)
				yyyy=$(($yyyy $operacao $quantidade))
			;;
			# Alien
			*)
				echo "Grandeza desconhecida '$grandeza'"
				return
			;;
		esac

		# Se o resultado for 29/02 em um ano não-bissexto, muda pra 28/02
		test $dd -eq 29 -a $mm -eq 2 &&	! zztool testa_ano_bissexto $yyyy && dd=28

		# Restaura o zero dos meses e dias menores que 10
		[ $dd -le 9 ] && dd=0$dd
		[ $mm -le 9 ] && mm=0$mm

		# Tá feito.
		echo $dd/$mm/$yyyy
		return
	fi
	
	# Se as duas datas foram informadas como dd/mm/aaaa,
	# ou se apenas uma data foi informada,
	# o resultado é o próprio número de dias, então terminamos.
	if (zztool grep_var / "$data1" && zztool grep_var / "$data2") ||
	   (zztool grep_var / "$data1" && test $# -eq 1)
	then
		echo $dias
		return
	fi
	
	# Como não caímos no IF anterior, então o resultado será uma data.
	# É preciso converter o número inteiro para dd/mm/aaaa.
	#
	# Se o número inteiro for positivo, temos uma data DEPOIS de Epoch
	# Se o número inteiro for negativo, temos uma data ANTES de Epoch
	#      03/01/1970 = 2
	#      02/01/1970 = 1
	#      01/01/1970 = 0
	#      31/12/1969 = -1
	#      30/12/1969 = -2

	if [ $dias -ge 0 ]
	then
		# POSITIVO: Inicia em 01/01/1970 e avança no tempo
		y=$epoch          # ano
		mm=1              # mês
		op='+'            # direção
		dias_mes="$dias_mes_ok"
	else
		# NEGATIVO: Inicia em 31/12/1969 e retrocede no tempo
		y=$((epoch - 1))  # ano
		mm=12             # mês
		op='-'            # direção
		dias_mes="$dias_mes_rev"
		
		# Valor negativo complica, vamos positivar: abs()
		dias=$((0 - dias))
	fi

	# O número da Epoch é zero-based, agora vai virar one-based
	dd=$(($dias $op 1))
	
	# Dias -> Ano
	while :
	do
		# Novamente, o ano bissexto é levado em conta
		dias_ano=365
		zztool testa_ano_bissexto $y && dias_ano=366
		
		# Vai descontando os dias de cada ano para saber quantos anos cabem

		# Não muda o ano se o número de dias for insuficiente
		[ $dd -lt $dias_ano ] && break

		# Se for exatamente igual ao total de dias, não muda o
		# ano se estivermos indo adiante no tempo (> Epoch).
		# Caso contrário vai mudar pois cairemos no último dia
		# do ano anterior.
		[ $dd -eq $dias_ano -a $op = '+' ] && break

		dd=$(($dd - $dias_ano))
		y=$(($y $op 1))
	done
	yyyy=$y
	
	# Dias -> mês
	for i in $dias_mes
	do
		# Fevereiro de ano bissexto tem 29 dias
		[ $dias_ano -eq 366 -a $i -eq 28 ] && i=29
	
		# Calcula quantos meses cabem nos dias que sobraram
		
		# Não muda o mês se o número de dias for insuficiente
		[ $dd -lt $i ] && break
		
		# Se for exatamente igual ao total de dias, não muda o
		# mês se estivermos indo adiante no tempo (> Epoch).
		# Caso contrário vai mudar pois cairemos no último dia
		# do mês anterior.
		[ $dd -eq $i -a $op = '+' ] && break
		
		dd=$(($dd - $i))
		mm=$(($mm $op 1))
	done
	dias_neste_mes=$i
	
	# Ano e mês estão OK, agora sobraram apenas os dias
	
	# Se estivermos antes de Epoch, os número de dias indica quanto
	# devemos caminhar do último dia do mês até o primeiro
	[ $op = '-' ] && dd=$(($dias_neste_mes - $dd))
	
	# Restaura o zero dos meses e dias menores que 10
	[ $dd -le 9 ] && dd=0$dd
	[ $mm -le 9 ] && mm=0$mm
	
	# E finalmente mostra o resultado em formato de data
	echo $dd/$mm/$yyyy
}
