# ----------------------------------------------------------------------------
# Faz cálculos com datas e/ou converte data->num e num->data.
# Que dia vai ser daqui 45 dias? Quantos dias há entre duas datas? zzdata!
# Quando chamada com apenas um parâmetro funciona como conversor de data
# para número inteiro (N dias passados desde Epoch) e vice-versa.
# Obs.: Leva em conta os anos bissextos     (Epoch = 01/01/1970, editável)
# Uso: zzdata data|num [+|- data|num]
# Ex.: zzdata 22/12/1999 + 69
#      zzdata hoje - 5
#      zzdata 01/03/2000 - 11/11/1999
#      zzdata hoje - dd/mm/aaaa         <---- use sua data de nascimento
#
# Autor: Aurélio Marinho Jargas, www.aurelio.net
# Desde: 2003-02-07
# Versão: 2
# Licença: GPL
# ----------------------------------------------------------------------------
zzdata ()
{
	zzzz -h data $1 && return

	local yyyy mm dd dias_ano data dias i m y op dias_mes dias_neste_mes
	local epoch=1970
	local primeira_data=1
	local dias_mes_ok='31 28 31 30 31 30 31 31 30 31 30 31'  # jan-dez
	local dias_mes_rev='31 30 31 30 31 31 30 31 30 31 28 31' # dez-jan
	local data1=$1
	local operacao=$2
	local data2=$3
	local n1=$data1
	local n2=$data2

	# Verificação dos parâmetros
	[ $# -eq 3 -o $# -eq 1 ] || { zztool uso data; return; }

	# Esse bloco gigante define $n1 e $n2 baseado nas datas $data1 e $data2.
	# A data é transformada em um número inteiro (dias desde $epoch).
	# Este é numero usado para fazer os cálculos.
	# Exemplos:
	#      03/01/1970 = 2
	#      02/01/1970 = 1
	#      01/01/1970 = 0
	#      31/12/1969 = -1
	#      30/12/1969 = -2
	
	for data in $data1 $data2
	do
		# Atalhos úteis para o dia atual
		if [ "$data" = 'hoje' -o "$data" = 'today' ]
		then
			# Qual a data de hoje?
			data=$(date +%d/%m/%Y)
			[ "$primeira_data" ] && data1=$data || data2=$data
		else
			# Valida o formato da data
			if ! ( zztool testa_data "$data" || zztool testa_numero_sinal "$data" )
			then
				echo "Data inválida '$data', deve ser dd/mm/aaaa"
				return
			fi
		fi
		
		# Se tem /, então é uma data e deve ser transformado em número
		if zztool grep_var / "$data"
		then
			# Extrai os componentes da data: ano, mês, dia
			yyyy=${data##*/}
			mm=${data#*/}
			mm=${mm%/*}
			dd=${data%%/*}

			# Retira o zero dos dias e meses menores que 10
			mm=${mm#0}
			dd=${dd#0}

			# Define o marco inicial e a direção dos cálculos
			if [ $yyyy -ge $epoch ]
			then
				# +Epoch: Inicia em 01/01/1970 e avança no tempo
				y=$epoch          # ano
				m=1               # mês
				op='+'            # direção
				dias=0            # 01/01/1970 == 0
				dias_mes="$dias_mes_ok"
			else
				# -Epoch: Inicia em 31/12/1969 e retrocede no tempo
				y=$((epoch - 1))  # ano
				m=12              # mês
				op='-'            # direção
				dias=-1           # 31/12/1969 == -1
				dias_mes="$dias_mes_rev"
			fi

			# Ano -> dias
			while :
			do
				# Sim, os anos bissextos são levados em conta!
				dias_ano=365
				zztool testa_ano_bissexto $y && dias_ano=366
				
				# Vai somando (ou subtraindo) até chegar no ano corrente
				[ $y -eq $yyyy ] && break
				dias=$(($dias $op $dias_ano))
				y=$(($y $op 1))
			done
			
			# Meses -> dias
			for i in $dias_mes
			do
				# Fevereiro de ano bissexto tem 29 dias
				[ $dias_ano -eq 366 -a $i -eq 28 ] && i=29

				# Vai somando (ou subtraindo) até chegar no mês corrente
				[ $m -eq $mm ] && break
				m=$(($m $op 1))
				dias=$(($dias $op $i))
			done
			dias_neste_mes=$i

			# -Epoch: o número de dias indica o quanto deve-se
			# retroceder à partir do último dia do mês
			[ $op = '-' ] && dd=$(($dias_neste_mes - $dd))

			# Somando os dias da data aos anos+meses já contados.
			dias=$(($dias $op $dd))
			
			# +Epoch: É substraído um do resultado pois 01/01/1970 == 0
			[ $op = '+' ] && dias=$((dias - 1))
			
			# O número inteiro que representa a data é salvo em n1 ou n2
			[ "$primeira_data" ] && n1=$dias || n2=$dias
		fi
		primeira_data=
	done
	
	# Agora que ambas as datas são números inteiros, a conta é feita
	dias=$(($n1 $operacao $n2))
	
	# Se as duas datas foram informadas como dd/mm/aaaa,
	# o resultado é o próprio número de dias, então terminamos.
	if [ "${data1##??/*}" = "${data2##??/*}" ]
	then
		echo $dias
		return
	fi
	
	# Como não caímos no IF anterior, então o resultado será uma data.
	# É preciso converter o número inteiro para dd/mm/aaaa.
	#
	# Se o número inteiro for positivo, temos uma data DEPOIS de Epoch
	# Se o número inteiro for negativo, temos uma data ANTES de Epoch
	#      03/01/1970 = 2
	#      02/01/1970 = 1
	#      01/01/1970 = 0
	#      31/12/1969 = -1
	#      30/12/1969 = -2

	if [ $dias -ge 0 ]
	then
		# POSITIVO: Inicia em 01/01/1970 e avança no tempo
		y=$epoch          # ano
		mm=1              # mês
		op='+'            # direção
		dias_mes="$dias_mes_ok"
	else
		# NEGATIVO: Inicia em 31/12/1969 e retrocede no tempo
		y=$((epoch - 1))  # ano
		mm=12             # mês
		op='-'            # direção
		dias_mes="$dias_mes_rev"
		
		# Valor negativo complica, vamos positivar: abs()
		dias=$((0 - dias))
	fi

	# O número da Epoch é zero-based, agora vai virar one-based
	dd=$(($dias $op 1))
	
	# Dias -> Ano
	while :
	do
		# Novamente, o ano bissexto é levado em conta
		dias_ano=365
		zztool testa_ano_bissexto $y && dias_ano=366
		
		# Vai descontando os dias de cada ano para saber quantos anos cabem

		# Não muda o ano se o número de dias for insuficiente
		[ $dd -lt $dias_ano ] && break

		# Se for exatamente igual ao total de dias, não muda o
		# ano se estivermos indo adiante no tempo (> Epoch).
		# Caso contrário vai mudar pois cairemos no último dia
		# do ano anterior.
		[ $dd -eq $dias_ano -a $op = '+' ] && break

		dd=$(($dd - $dias_ano))
		y=$(($y $op 1))
	done
	yyyy=$y
	
	# Dias -> mês
	for i in $dias_mes
	do
		# Fevereiro de ano bissexto tem 29 dias
		[ $dias_ano -eq 366 -a $i -eq 28 ] && i=29
	
		# Calcula quantos meses cabem nos dias que sobraram
		
		# Não muda o mês se o número de dias for insuficiente
		[ $dd -lt $i ] && break
		
		# Se for exatamente igual ao total de dias, não muda o
		# mês se estivermos indo adiante no tempo (> Epoch).
		# Caso contrário vai mudar pois cairemos no último dia
		# do mês anterior.
		[ $dd -eq $i -a $op = '+' ] && break
		
		dd=$(($dd - $i))
		mm=$(($mm $op 1))
	done
	dias_neste_mes=$i
	
	# Ano e mês estão OK, agora sobraram apenas os dias
	
	# Se estivermos antes de Epoch, os número de dias indica quanto
	# devemos caminhar do último dia do mês até o primeiro
	[ $op = '-' ] && dd=$(($dias_neste_mes - $dd))
	
	# Restaura o zero dos meses e dias menores que 10
	[ $dd -le 9 ] && dd=0$dd
	[ $mm -le 9 ] && mm=0$mm
	
	# E finalmente mostra o resultado em formato de data
	echo $dd/$mm/$yyyy
}
